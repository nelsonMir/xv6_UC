# ============================================
#  Plataforma / Toolchain / Rutas
# ============================================

# Plataforma objetivo
platform := vf2

# Rutas
K = kernel
U = user
T = target

# Herramientas de compilación cruzada
TOOLPREFIX := riscv64-unknown-elf-
CC      = $(TOOLPREFIX)gcc
AS      = $(TOOLPREFIX)as
LD      = $(TOOLPREFIX)ld
OBJCOPY = $(TOOLPREFIX)objcopy
OBJDUMP = $(TOOLPREFIX)objdump

# Flags de compilación
# -ggdb/-gdwarf-2 para depuración; -fno-omit-frame-pointer para backtraces
# -mcmodel=medany y sin stdlib, sin builtins peligrosos; incluye kernel/ y user/
CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
CFLAGS += -MD -mcmodel=medany -fno-common -nostdlib
CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
CFLAGS += -fno-builtin-free -fno-builtin-memcpy -Wno-main
CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
CFLAGS += -I. -Ikernel -Iuser -I$(CURDIR)/kernel -I$(CURDIR)/user
CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

# Linker script
ifeq ($(platform), vf2)
linker = ./linker/vf2.ld
endif

# ============================================
#  Objetos del kernel
# ============================================

OBJS = \
  $(K)/entry_vf2.o \
  $(K)/start.o \
  $(K)/console.o \
  $(K)/printf.o \
  $(K)/uart.o \
  $(K)/kalloc.o \
  $(K)/spinlock.o \
  $(K)/string.o \
  $(K)/main.o \
  $(K)/vm.o \
  $(K)/proc.o \
  $(K)/swtch.o \
  $(K)/trampoline.o \
  $(K)/trap.o \
  $(K)/syscall.o \
  $(K)/sysproc.o \
  $(K)/bio.o \
  $(K)/fs.o \
  $(K)/log.o \
  $(K)/sleeplock.o \
  $(K)/file.o \
  $(K)/pipe.o \
  $(K)/exec.o \
  $(K)/sysfile.o \
  $(K)/kernelvec.o \
  $(K)/plic.o \
  $(K)/ramdisk_xv6.o \
  $(K)/schedulers.o \
  $(K)/initcode_blob.o    # <— definición real del blob initcode

# Librerías de usuario
ULIB = $(U)/ulib.o $(U)/usys.o $(U)/printf.o $(U)/umalloc.o

# Programas de usuario
UPROGS = \
  $(U)/_cat \
  $(U)/_echo \
  $(U)/_forktest \
  $(U)/_grep \
  $(U)/_init \
  $(U)/_kill \
  $(U)/_ln \
  $(U)/_ls \
  $(U)/_mkdir \
  $(U)/_rm \
  $(U)/_sh \
  $(U)/_stressfs \
  $(U)/_usertests \
  $(U)/_grind \
  $(U)/_wc \
  $(U)/_zombie \
  $(U)/_sleep \
  $(U)/_freemem \
  $(U)/_pagesize \
  $(U)/_ps \
  $(U)/_getpriority \
  $(U)/_nice \
  $(U)/_pwd

# ============================================
#  Kernel final (ELF + bin) y símbolos
# ============================================

$(T)/kernel.bin: $(OBJS) $(linker) fs.img
	@mkdir -p $(T)
	$(LD) -T $(linker) -o $(T)/kernel $(OBJS)
	$(OBJDUMP) -S $(T)/kernel > $(T)/kernel.asm
	$(OBJDUMP) -t $(T)/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(T)/kernel.sym
	$(OBJCOPY) -O binary $(T)/kernel $(T)/kernel.bin

# ============================================
#  initcode: **ELF → BIN → C (blob) → .o**
#  IMPORTANTE: el header ya no se usa; generamos un .c con la DEFINICIÓN real
#  para evitar dobles inclusiones y garantizar que el tamaño < 4096.
# ============================================

# 1) Ensamblar initcode.S y enlazar ELF mínimo
#    -N: sin alineación por páginas; -e start: entry; -Ttext 0: código en 0
$(U)/initcode.elf: $(U)/initcode.S
	$(AS) -o $(U)/initcode.o $<
	$(LD) -N -e start -Ttext 0 -o $@ $(U)/initcode.o

# 2) BINARIO PLANO (esto debe pesar << 4096 bytes)
$(U)/initcode: $(U)/initcode.elf
	$(OBJCOPY) -S -O binary $< $@

# 3) Generar un .c con el array (definición real en un único TU)
#    - renombrar símbolos a 'initcode' y 'initcode_len = sizeof(initcode)'
kernel/initcode_blob.c: $(U)/initcode
	@echo "Generando kernel/initcode_blob.c desde user/initcode..."
	@echo "/* AUTOGENERATED: do not edit */" > $@
	@xxd -i $< | sed 's/user_initcode/initcode/g; s/unsigned int initcode_len;/unsigned int initcode_len = sizeof(initcode);/' >> $@

# 4) Compilar el blob a .o y enlazarlo en el kernel
$(K)/initcode_blob.o: kernel/initcode_blob.c
	$(CC) $(CFLAGS) -c -o $@ $<

# ============================================
#  Userland: reglas de soporte y programas
# ============================================

$(U)/usys.S: $(U)/usys.pl
	perl $< > $@

$(U)/usys.o: $(U)/usys.S
	$(CC) $(CFLAGS) -c -o $@ $<

$(U)/ulib.o: $(U)/ulib.c
	$(CC) $(CFLAGS) -c -o $@ $<

$(U)/printf.o: $(U)/printf.c
	$(CC) $(CFLAGS) -c -o $@ $<

$(U)/umalloc.o: $(U)/umalloc.c
	$(CC) $(CFLAGS) -c -o $@ $<

# init.c (programa de usuario _init)
$(U)/init.o: $(U)/init.c
	$(CC) $(CFLAGS) -c -o $@ $<

# Enlazado genérico de userland a ELF con user.ld
$(U)/_%: $(U)/%.o $(ULIB)
	$(LD) -T $(U)/user.ld -o $@ $^
	$(OBJDUMP) -S $@ > $(basename $@).asm
	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(basename $@).sym

# ============================================
#  Imagen de sistema de archivos (fs.img)
#  - Depende del BINARIO plano de initcode (para que quepa en 1 página)
# ============================================

fs.img: mkfs/mkfs README $(UPROGS) $(U)/initcode
	cp $(U)/_init $(U)/init
	mkfs/mkfs fs.img README $(UPROGS) $(U)/init

# Generar kernel/fsimg.h automáticamente desde fs.img
kernel/fsimg.h: fs.img
	@echo "Convirtiendo fs.img a fsimg.h..."
	@xxd -i fs.img > kernel/fsimg.h

# Asegurarse de que ramdisk_xv6.o dependa de fsimg.h
$(K)/ramdisk_xv6.o: $(K)/ramdisk_xv6.c kernel/fsimg.h
	$(CC) $(CFLAGS) -c -o $@ $<

# ============================================
#  mkfs
# ============================================

mkfs/mkfs: mkfs/mkfs.c
	gcc -Wall -Werror -Wno-stringop-truncation -O2 -I. -o $@ $<

# ============================================
#  QEMU (útil para pruebas rápidas en virt)
# ============================================

QEMU = qemu-system-riscv64
QEMUOPTS = -machine virt -bios none -kernel $(T)/kernel -m 128M -smp 3 -nographic
QEMUOPTS += -global virtio-mmio.force-legacy=false
QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

qemu: $(T)/kernel fs.img
	$(QEMU) $(QEMUOPTS)

# ============================================
#  Limpieza
# ============================================

.PHONY: clean
clean:
	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg
	rm -f */*.o */*.d */*.asm */*.sym
	rm -f $(T)/kernel $(T)/kernel.bin $(T)/kernel.asm $(T)/kernel.sym
	rm -f fs.img kernel/fsimg.h
	rm -f $(U)/usys.S $(UPROGS)
	rm -f $(U)/init $(U)/initcode $(U)/initcode.o $(U)/initcode.elf
	rm -f kernel/initcode_blob.c $(K)/initcode_blob.o

# ============================================
#  Dependencias de .d (auto-includes)
# ============================================
-include $(wildcard */*.d)
